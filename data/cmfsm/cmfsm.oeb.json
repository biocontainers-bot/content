
{
    "credit": [
        {
            "email": "zouquan@nclab.net",
            "name": "Quan Zou",
            "typeEntity": "Person",
            "typeRoles": [
                "Primary contact"
            ]
        },
        {
            "email": "benyunshi@outlook.com",
            "name": "Benyun Shi",
            "typeEntity": "Person",
            "typeRoles": [
                "Primary contact"
            ]
        },
        {
            "email": "pengshaoliang@nudt.edu.cn",
            "name": "Shaoliang PengEmail author",
            "typeEntity": "Person",
            "typeRoles": [
                "Primary contact"
            ]
        }
    ],
    "documentation": [
        {
            "type": "General",
            "url": "https://github.com/ysycloud/cmFSM/blob/master/README.md"
        }
    ],
    "function": [
        {
            "operation": [
                {
                    "term": "Optimisation and refinement",
                    "uri": "http://edamontology.org/operation_2425"
                }
            ]
        }
    ],
    "labels": {
        "language": [
            "C++"
        ],
        "toolType": [
            "Command-line tool"
        ],
        "topic": [
            {
                "term": "Drug discovery",
                "uri": "http://edamontology.org/topic_3336"
            }
        ]
    },
    "publication": [
        {
            "abstract": "Â© 2018 The Author(s). Background: Frequent subgraphs mining is a significant problem in many practical domains. The solution of this kind of problem can particularly used in some large-scale drug molecular or biological libraries to help us find drugs or core biological structures rapidly and predict toxicity of some unknown compounds. The main challenge is its efficiency, as (i) it is computationally intensive to test for graph isomorphisms, and (ii) the graph collection to be mined and mining results can be very large. Existing solutions often require days to derive mining results from biological networks even with relative low support threshold. Also, the whole mining results always cannot be stored in single node memory. Results: In this paper, we implement a parallel acceleration tool for classical frequent subgraph mining algorithm called cmFSM. The core idea is to employ parallel techniques to parallelize extension tasks, so as to reduce computation time. On the other hand, we employ multi-node strategy to solve the problem of memory constraints. The parallel optimization of cmFSM is carried out on three different levels, including the fine-grained OpenMP parallelization on single node, multi-node multi-process parallel acceleration and CPU-MIC collaborated parallel optimization. Conclusions: Evaluation results show that cmFSM clearly outperforms the existing state-of-the-art miners even if we only hold a few parallel computing resources. It means that cmFSM provides a practical solution to frequent subgraph mining problem with huge number of mining results. Specifically, our solution is up to one order of magnitude faster than the best CPU-based approach on single node and presents a promising scalability of massive mining tasks in multi-node scenario. More source code are available at:Source Code: https://github.com/ysycloud/cmFSM.",
            "authors": [
                "Yang S.",
                "Guo R.",
                "Liu R.",
                "Liao X.",
                "Zou Q.",
                "Shi B.",
                "Peng S."
            ],
            "cit_count": 0,
            "doi": "10.1186/s12859-018-2071-z",
            "journal": "BMC Bioinformatics",
            "title": "cmFSM: A scalable CPU-MIC coordinated drug-finding tool by frequent subgraph mining",
            "type": "Primary",
            "year": "2018-05-08"
        }
    ],
    "summary": {
        "biotoolsCURIE": "biotools:cmfsm",
        "biotoolsID": "cmfsm",
        "description": "A parallel acceleration tool for classical frequent subgraph mining algorithm. The core idea is to employ parallel techniques to parallelize extension tasks, so as to reduce computation time. On the other hand, multi-node strategy is employed to solve the problem of memory constraints.",
        "homepage": "https://github.com/ysycloud/cmFSM",
        "name": "cmFSM"
    }
}